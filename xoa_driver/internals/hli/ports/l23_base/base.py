import functools
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from xoa_driver.internals.core import interfaces as itf
from xoa_driver.internals.commands import *
from xoa_driver.internals.utils import attributes as utils
from xoa_driver.internals.hli.ports import base_port
from xoa_driver.internals.utils.indices import index_manager as idx_mgr
from xoa_driver.internals.hli.indices.streams.genuine_stream import GenuineStreamIdx
from xoa_driver.internals.hli.indices.filter.genuine_filter import GenuineFilterIdx
from xoa_driver.internals.hli.indices.port_dataset import PortDatasetIdx
from xoa_driver.internals.state_storage import ports_state
from xoa_driver.internals.hli.indices.length_term import LengthTermIdx
from xoa_driver.internals.hli.indices.match_term import MatchTermIdx
from xoa_driver.internals.hli.indices.macsecscs.genuine_macsecsc import GenuineMacSecTxScIdx, GenuineMacSecRxScIdx

from .port_capture import PortCapture
from .port_statistics_rx import PortReceptionStatistics
from .port_statistics_tx import PortTransmissionStatistics
from .port_layer1 import PortLayer1

LengthTermIndices = idx_mgr.IndexManager[LengthTermIdx] # type: ignore
MatchTermIndices = idx_mgr.IndexManager[MatchTermIdx] # type: ignore
StreamIndices = idx_mgr.IndexManager[GenuineStreamIdx] # type: ignore
FilterIndices = idx_mgr.IndexManager[GenuineFilterIdx] # type: ignore
PortDatasetIndices = idx_mgr.IndexManager[PortDatasetIdx] # type: ignore
MacSecTxScIndices = idx_mgr.IndexManager[GenuineMacSecTxScIdx] # type: ignore
MacSecRxScIndices = idx_mgr.IndexManager[GenuineMacSecRxScIdx] # type: ignore

class TxSinglePacket:
    """Single-packet transmission"""

    def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
        self.send = P_XMITONE(conn, module_id, port_id)
        """Send one packet from the without a stream config.

        :type: P_XMITONE
        """

        self.time = P_XMITONETIME(conn, module_id, port_id)
        """The time at which the latest packet was transmitted using the ``send`` attribute.

        :type: P_XMITONETIME
        """


class TxControl:
    """TX control"""

    def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
        self.mode = P_TXMODE(conn, module_id, port_id)
        """Scheduling mode for the outgoing traffic from the port. 

        :type: P_TXMODE
        """

        self.enable = P_TXENABLE(conn, module_id, port_id)
        """Control Tx on or off. 

        :type: P_TXENABLE
        """

        self.time_limit = P_TXTIMELIMIT(conn, module_id, port_id)
        """The duration port transmission. The port will stop transmitting after this time limit is reached. If the time limit is set to 0, the port will transmit indefinitely until stopped by the user.

        :type: P_TXTIMELIMIT
        """

        self.elapsed_time = P_TXTIME(conn, module_id, port_id)
        """Elapsed time since the port started transmitting. This value is reset to 0 when the port is stopped or when the time limit is set to 0.

        :type: P_TXTIME
        """

        self.prepare = P_TXPREPARE(conn, module_id, port_id)
        """Prepare the port for transmission. This attribute is used to prepare the port for transmission before starting the traffic. It is useful when the port is in a state that requires preparation before sending traffic.

        :type: P_TXPREPARE
        """

        self.delay = P_TXDELAY(conn, module_id, port_id)
        """Tx delay configuration. This attribute sets the delay for the transmission of packets from the port. The delay is applied to all packets transmitted from the port, and it can be used to simulate network latency or to synchronize traffic with other ports.

        :type: P_TXDELAY
        """

        self.packet_limit = P_TXPACKETLIMIT(conn, module_id, port_id)
        """The maximum number of packets to be transmitted from the port. This attribute sets a limit on the number of packets that can be transmitted from the port. Once the limit is reached, the port will stop transmitting until the limit is reset or changed.

        :type: P_TXPACKETLIMIT
        """

        self.burst_period = P_TXBURSTPERIOD(conn, module_id, port_id)
        """TX burst period configuration. This attribute sets the period for the transmission of packets from the port in burst mode. The burst period is the time interval between bursts of packets transmitted from the port. It can be used to control the rate of traffic generated by the port and to simulate bursty traffic patterns.

        :type: P_TXBURSTPERIOD
        """

        self.single_pkt = TxSinglePacket(conn, module_id, port_id)
        """Single-packet transmission configuration. This attribute allows the user to send a single packet from the port without using a stream configuration. It is useful for testing and debugging purposes, as well as for sending specific packets without the need for a full traffic stream.

        :type: TxSinglePacket
        """

        self.dynamic = P_DYNAMIC(conn, module_id, port_id)
        """Dynamic traffic configuration. This attribute allows the user to enable or disable dynamic traffic generation on the port. When dynamic traffic is enabled, the user can change the stream rate, packe size, and size type dynamically without stopping the traffic. This feature is useful for testing and simulating different traffic patterns without the need to stop and restart the traffic generation.
        
        :type: P_DYNAMIC
        """


class TrafficRate:
    """TX rate"""

    def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
        self.fraction = P_RATEFRACTION(conn, module_id, port_id)
        """Rate in ppm. This attribute sets the rate at which packets are transmitted from the port as a fraction of the maximum rate. The value can be set between 0 and 1_000_000, where 1_000_000 represents 100% of the maximum rate.

        :type: P_RATEFRACTION
        """

        self.pps = P_RATEPPS(conn, module_id, port_id)
        """Rate in packets per second. This attribute sets the rate at which packets are transmitted from the port in terms of packets per second (PPS). The value can be set to any positive integer, and it determines how many packets will be sent from the port every second.

        :type: P_RATEPPS
        """

        self.l2_bps = P_RATEL2BPS(conn, module_id, port_id)
        """Rate in L2 bits per second. This attribute sets the rate at which packets are transmitted from the port in terms of Layer 2 bits per second (bps). The value can be set to any positive integer, and it determines how many bits will be sent from the port every second.

        :type: P_RATEL2BPS
        """


class Multicast:
    """Multicast configuration"""

    def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
        self.config = P_MULTICAST(conn, module_id, port_id)
        """Basic multicast configuration. 

        :type: P_MULTICAST
        """

        self.config_extended = P_MULTICASTEXT(conn, module_id, port_id)
        """Extended multicast configuration. This attribute extends the multicast configuration with additional parameters such as IGMP version.

        :type: P_MULTICASTEXT
        """

        self.source_list = P_MCSRCLIST(conn, module_id, port_id)
        """Multicast source list. This attribute allows the user to configure a list of multicast sources for the port. The source list can be used to filter incoming multicast traffic based on the specified sources. It is useful for controlling which multicast streams are allowed on the port and for managing multicast traffic efficiently.

        :type: P_MCSRCLIST
        """

        self.header = P_MULTICASTHDR(conn, module_id, port_id)
        """Multicast IGMP header. This attribute allows the user to configure the IGMP header for multicast traffic. The IGMP header is used to manage multicast group membership and to control the flow of multicast traffic on the port. It is essential for proper multicast operation and for ensuring that multicast packets are delivered to the correct destinations.

        :type: P_MULTICASTHDR
        """

        self.igmpv3_group_record_bundle = P_IGMPV3_GROUP_RECORD_BUNDLE(conn, module_id, port_id)
        """Configure if a single membership report bundles multiple Multicast group records to decrease the number of packets sent when using IGMPv3. This attribute returns <NOTVALID> when the IGMP version is not IGMPv3.

        :type: P_IGMPV3_GROUP_RECORD_BUNDLE
        """

class IPv4:
    """IPv4 configuration"""

    def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
        self.address = P_IPADDRESS(conn, module_id, port_id)
        """IPv4 address configuration. This attribute allows the user to configure the IPv4 address for the port. The IPv4 address is used for communication over IP networks and is essential for routing traffic to and from the port.

        :type: P_IPADDRESS
        """

        self.arp_reply = P_ARPREPLY(conn, module_id, port_id)
        """Reply to ARP request. This attribute allows the user to configure the ARP reply behavior for the port. When an ARP request is received, the port can respond with the port MAC address. 
        
        If the port ARP table is filled with entries, the port will respond to ARP requests with the MAC address of the entry that matches the request. 
        
        If no matching entry is found, the port will not respond to the ARP request.

        :type: P_ARPREPLY
        """

        self.ping_reply = P_PINGREPLY(conn, module_id, port_id)
        """Reply to PING request. This attribute allows the user to configure the port to respond to PING requests. When a PING request is received, the port can send a reply back to the sender, indicating that the port is reachable and operational.

        :type: P_PINGREPLY
        """


class IPv6:
    """IPv6 configuration"""

    def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
        self.address = P_IPV6ADDRESS(conn, module_id, port_id)
        """IPv6 address configuration. This attribute allows the user to configure the IPv6 address for the port. The IPv6 address is used for communication over IPv6 networks and is essential for routing traffic to and from the port.

        :type: P_IPV6ADDRESS
        """

        self.ndp_reply = P_ARPV6REPLY(conn, module_id, port_id)
        """Reply to NDP Neighbor Solicitation. This attribute allows the user to configure the NDP reply behavior for the port. When an NDP request is received, the port can respond with the port MAC address. 
        
        If the port NDP table is filled with entries, the port will respond to NDP requests with the MAC address of the entry that matches the request. 
        
        If no matching entry is found, the port will not respond to the NDP request.

        :type: P_ARPV6REPLY
        """

        self.ping_reply = P_PINGV6REPLY(conn, module_id, port_id)
        """Reply to PINGv6 request.

        :type: P_PINGV6REPLY
        """
        


class LatencyConfiguration:
    """Latency configuration"""

    def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
        self.offset = P_LATENCYOFFSET(conn, module_id, port_id)
        """Latency offset.

        :type: P_LATENCYOFFSET
        """

        self.mode = P_LATENCYMODE(conn, module_id, port_id)
        """Latency measurement mode.

        Latency is measured by inserting a time-stamp in each packet when it is
        transmitted, and relating it to the time when the packet is received. There are
        four separate modes for calculating the latency:

        1)  Last-bit-out to last-bit-in, which measures basic bit-transit time,
            independent of packet length.
        2)  First-bit-out to last-bit-in, which adds the time taken to transmit the
            packet itself.
        3)  Last-bit-out to first-bit-in, which subtracts the time taken to transmit the
            packet itself. The same latency mode must be configured for the transmitting
            port and the receiving port; otherwise invalid measurements will occur.
        4)  First-bit-out to first-bit-in, which adds the time taken to transmit the
            packet itself, and subtracts the time taken to transmit the packet itself.
            The same latency mode must be configured for the transmitting
            port and the receiving port; otherwise invalid measurements will occur.


        :type: P_LATENCYMODE
        """


class IMix:
    """IMIX configuration"""

    def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
        self.weights = P_MIXWEIGHTS(conn, module_id, port_id)
        """IMIX weights configuration. Allow changing the distribution of the MIX packet length by specifying the percentage of each of the 16 possible frame sizes used in the MIX.  The sum of the percentage values specified must be 100. The attribute will affect the mix-distribution for all streams on the port.

        :type: P_MIXWEIGHTS
        """

        self.lengths = tuple(
            P_MIXLENGTH(conn, module_id, port_id, idx)
            for idx in range(16)
        )  # TODO: need to add manager for handle specific indices only
        """IMIX lengths. Allows inspecting the frame sizes defined for each position of the ``weights`` attribute. By default, the 16 frame sizes are: 56 , 60, 64, 70, 78, 92, 256, 496, 512, 570, 576, 594, 1438, 1518, 9216, and 16360. In addition to inspecting these sizes one by one, it also allows changing frame size for the positions adverstised in ``capabilities``.

        :type: P_MIXLENGTH
        """
        


class Traffic:
    """Traffic generation"""

    def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
        self.state = P_TRAFFIC(conn, module_id, port_id)
        """Port traffic state control. This attribute allows the user to control the traffic state of the port.

        :type: P_TRAFFIC
        """

        self.error = P_TRAFFICERR(conn, module_id, port_id)
        """Port traffic error.

        :type: P_TRAFFICERR
        """


class FlowControl:
    """Flow control configuration"""

    def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:

        self.pause = P_PAUSE(conn, module_id, port_id)
        """Response to Ethernet PAUSE frames. This attribute allows the user to configure the port to respond to Ethernet PAUSE frames. When a PAUSE frame is received, the port can pause its transmission for a specified duration, allowing the network to manage congestion and prevent packet loss.

        :type: P_PAUSE
        """

        self.pfc = P_PFCENABLE(conn, module_id, port_id)
        """Ethernet Priority Flow Control (PFC). This attribute allows the user to enable or disable Ethernet Priority Flow Control (PFC) on the port. PFC is a mechanism that allows the port to pause traffic on a per-priority basis, enabling fine-grained control over traffic flow and preventing congestion in networks that support multiple priorities.

        :type: P_PFCENABLE
        """

class Speed:
    def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
        self.selection = P_SPEEDSELECTION(conn, module_id, port_id)
        """Port speed mode selection. This attribute allows the user to select the speed mode for the port. The speed mode determines the data rate at which the port operates, and it can be set to various values depending on the capabilities of the port and the connected network.

        :type: P_SPEEDSELECTION
        """

        self.supported = P_SPEEDS_SUPPORTED(conn, module_id, port_id)
        """Supported speed modes. This attribute provides a list of speed modes that are supported by the port. It allows the user to see which speed modes are available for selection and can be used to configure the port to operate at a specific speed.

        :type: P_SPEEDS_SUPPORTED
        """

        self.current = P_SPEED(conn, module_id, port_id)
        """Current speed in units of Mbps. This attribute provides the current speed of the port in megabits per second (Mbps). It reflects the speed at which the port is currently operating.

        :type: P_SPEED
        """

        self.reduction = P_SPEEDREDUCTION(conn, module_id, port_id)
        """Speed reduction in ppm. This attribute allows the user to configure the speed reduction for the port in parts per million (ppm). Speed reduction can be used to adjust the effective speed of the port, allowing for fine-tuning of the port's performance in specific network conditions.

        :type: P_SPEEDREDUCTION
        """


class UnavailableTime:
    """UnAvailable Time configuration"""

    def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
        self.mode = P_UAT_MODE(conn, module_id, port_id)
        """Unavailable Time mode. This attribute allows the user to configure the Unavailable Time mode for the port. Unavailable Time is a period during which the port is not available for traffic transmission, and it can be used to simulate network conditions or to manage traffic flow.

        :type: P_UAT_MODE
        """

        self.frame_loss_ratio = P_UAT_FLR(conn, module_id, port_id)
        """Frame Loss Ratio for UAT. This attribute allows the user to configure the Frame Loss Ratio (FLR) for the Unavailable Time mode. The FLR is a measure of the percentage of frames that are lost during the Unavailable Time period, and it can be used to simulate network conditions or to manage traffic flow.

        :type: P_UAT_FLR
        """


class Statistics:
    """statistics"""

    def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
        self.rx = PortReceptionStatistics(conn, module_id, port_id)
        """Port RX statistics. This attribute provides access to the RX statistics of the port, including total traffic, errors, and other relevant metrics.

        :type: PortReceptionStatistics
        """

        self.tx = PortTransmissionStatistics(conn, module_id, port_id)
        """Port TX statistics. This attribute provides access to the TX statistics of the port, including total traffic, errors, and other relevant metrics.
        
        :type: PortTransmissionStatistics
        """


class MacControl:
    """MAC control configuration
    """
    def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:

        self.address = P_MACADDRESS(conn, module_id, port_id)
        """MAC address configuration. This attribute allows the user to configure the MAC address for the port.

        :type: P_MACADDRESS
        """

        self.autotrain = P_AUTOTRAIN(conn, module_id, port_id)
        """Interval between MAC auto training packets. This attribute allows the user to configure the interval at which MAC auto training packets are sent. Auto training packets are used to optimize the performance of the MAC layer and to ensure proper communication between devices.

        :type: P_AUTOTRAIN
        """


class EnergyEfficientEthernet:
    """Energy Efficient Ethernet (EEE) configuration."""

    def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
        self.enable = P_LPENABLE(conn, module_id, port_id)
        """Enable/disable Energy Efficiency Ethernet.
        
        :type: P_LPENABLE
        """

        self.mode = P_LPTXMODE(conn, module_id, port_id)
        """Port EEE mode. This attribute allows the user to configure the EEE mode for the port. The EEE mode determines how the port operates in terms of energy efficiency and power management.
        
        :type: P_LPTXMODE
        """

        self.status = P_LPSTATUS(conn, module_id, port_id)
        """Port EEE status. This attribute provides the current status of the EEE configuration for the port. It indicates whether EEE is enabled or disabled, and it may also provide additional information about the EEE operation.
        
        :type: P_LPSTATUS
        """

        self.partner_capabilities = P_LPPARTNERAUTONEG(conn, module_id, port_id)
        """EEE capabilities advertised during auto-negotiation by the far side.
        
        :type: P_LPPARTNERAUTONEG
        """

        self.snr_margin = P_LPSNRMARGIN(conn, module_id, port_id)
        """SNR margin on the four link channels by the PHY.
        
        :type: P_LPSNRMARGIN
        """

        self.rx_power = P_LPRXPOWER(conn, module_id, port_id)
        """RX power recorded during training for the four channels.
        
        :type: P_LPRXPOWER
        """

        self.capabilities = P_LPSUPPORT(conn, module_id, port_id)
        """EEE capabilities of the port.
        
        :type: P_LPSUPPORT
        """


class Runt:
    """Runt frame configuration."""

    def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
        self.tx_length = P_TXRUNTLENGTH(conn, module_id, port_id)
        """TX runt length. This attribute allows the user to enable TX runt feature to cut all packets to a number of bytes.
        
        :type: P_TXRUNTLENGTH
        """

        self.rx_length = P_RXRUNTLENGTH(conn, module_id, port_id)
        """RX runt length. Enable RX runt length detection to flag if packets are seen with length not being the give length in bytes.
        
        :type: P_RXRUNTLENGTH
        """

        self.has_length_errors = P_RXRUNTLEN_ERRS(conn, module_id, port_id)
        """RX runt length errors. Sticky clear on read: Have packets with wrong runt length been detected since last read?
        
        :type: P_RXRUNTLEN_ERRS
        """


class Preamble:
    """Preamble configuration."""

    def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
        self.tx_remove = P_TXPREAMBLE_REMOVE(conn, module_id, port_id)
        """Removal of preamble from outgoing packets.
        
        :type: P_TXPREAMBLE_REMOVE
        """

        self.rx_insert = P_RXPREAMBLE_INSERT(conn, module_id, port_id)
        """Insert preamble into incoming packets.
        
        :type: P_RXPREAMBLE_INSERT
        """

class Payload:
    """Payload configuration."""

    def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
        self.mode = P_PAYLOADMODE(conn, module_id, port_id)
        """Payload mode. Set this command to configure the port to use different payload modes, i.e. normal, extend payload, and custom payload field, for ALL streams on this port. The extended payload feature allows the definition of a much larger (up to MTU) payload buffer for each stream. The custom payload field feature allows you to define a sequence of custom data fields for each stream. The data fields will then be used in a round robin fashion when packets are sent based on the stream definition.

        :type: P_PAYLOADMODE
        """

        self.random_seed = P_RANDOMSEED(conn, module_id, port_id)
        """Random seed value. A fixed seed value specified for a port. This value is used for a pseudo-random number generator used when generating traffic that requires random variation in packet length, payload, or modified fields. As long as no part of the port configuration is changed, the generated traffic patterns are reproducible when restarting traffic for the port. A specified seed value of -1 instead creates variation by using a new time-based seed value each time traffic generation is restarted.

        :type: P_RANDOMSEED
        """

        self.checksum_offset = P_CHECKSUM(conn, module_id, port_id)
        """The offset where payload checksum offset calculation starts. Controls an extra payload integrity checksum, which also covers the header protocols following the Ethernet header. It will therefore catch any modifications to the protocol fields (which should therefore not have modifiers on them).

        :type: P_CHECKSUM
        """

        self.max_header_length = P_MAXHEADERLENGTH(conn, module_id, port_id)
        """Maximum stream header length. The maximum number of header content bytes that can be freely specified for each generated stream. The remaining payload bytes of the packet are auto-generated.The default is 128 bytes. When a larger number is select there is a corresponding proportional reduction in the number of stream definitions that are available for the port. Possible values: 128 (default), 256, 512, 1024, 2048.

        :type: P_MAXHEADERLENGTH
        """

class TPLD:
    """Test payload configuration."""

    def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
        self.mode = P_TPLDMODE(conn, module_id, port_id)
        """Test payload mode. Default is "Normal", which is a 20 byte TPLD. "Micro" is a condensed version, which is useful when generating very small packets with relatively long headers (like IPv6). 

        Micro TPLD has the following characteristics compared to the "normal" TPLD. 
    
        1) Only 6 byte long. 
        2) Less accurate mechanism to separate Xena-generated packets from other packets is the network - it is recommended not to have too much other traffic going into the receive Xena port, when micro TPLD is used.
        3) No sequence checking (packet loss or packet misordering). The number of received packets for each stream can still be compared to the number of transmitted packets to detect packet loss once traffic has been stopped.

        :type: P_TPLDMODE
        """

        self.used_tpld_ids = P_USED_TPLDID(conn, module_id, port_id)
        """Used TPLD IDs. Get the used TPLD IDs from the port. If the port doesn't support TPLD ID traffic, the port will return <NOTSUPPORTED>

        :type: P_USED_TPLDID
        """


class BRR:
    """BroadR-Reach configuration."""

    def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
        
        self.brr_mode = P_BRRMODE(conn, module_id, port_id)
        """BRR mode. Selects the Master/Slave setting of 100 Mbit/s, 1000 Mbit/s BroadR-Reach copper interfaces.
        
        :type: P_BRRMODE
        """
        self.brr_status = P_BRRSTATUS(conn, module_id, port_id)
        """Get the actual BroadR-Reach status of the port.
        
        :type: P_BRRSTATUS
        """

class PortL23Base(base_port.BasePort[ports_state.PortL23LocalState]):
    """PortL23 is the base class for Xena port configurations."""

    def __init__(self, conn: "itf.IConnection", module_id: int, port_id: int) -> None:
        super().__init__(conn, module_id, port_id)

        self._local_states = ports_state.PortL23LocalState()

        self.streams: StreamIndices = idx_mgr.IndexManager(
            conn,
            GenuineStreamIdx, # type: ignore
            module_id,
            port_id
        )
        """Stream Index Manager automatically creates and manages stream indices for the port.
        This allows for easy access and manipulation of stream configurations without the need to manually create or manage individual stream indices.

        :type: StreamIndices
        """

        self.length_terms: LengthTermIndices = idx_mgr.IndexManager(
            conn,
            LengthTermIdx, # type: ignore
            module_id,
            port_id
        )
        """Length Term Index Manager automatically creates and manages length term indices for the port.
        This allows for easy access and manipulation of length term configurations without the need to manually create or manage individual length term indices.

        :type: LengthTermIndices
        """

        self.match_terms: MatchTermIndices = idx_mgr.IndexManager(
            conn,
            MatchTermIdx, # type: ignore
            module_id,
            port_id
        )
        """Match Term Index Manager automatically creates and manages match term indices for the port.
        This allows for easy access and manipulation of match term configurations without the need to manually create or manage individual match term indices.

        :type: MatchTermIndices
        """

        self.filters: FilterIndices = idx_mgr.IndexManager(
            conn,
            GenuineFilterIdx, # type: ignore
            module_id,
            port_id
        )
        """Filter Index Manager automatically creates and manages filter indices for the port.
        This allows for easy access and manipulation of filter configurations without the need to manually create or manage individual filter indices.

        :type: FilterIndices
        """

        self.datasets: PortDatasetIndices = idx_mgr.IndexManager(
            conn,
            PortDatasetIdx, # type: ignore
            module_id,
            port_id
        )
        """Histogram Index Manager automatically creates and manages port dataset indices for the port.
        This allows for easy access and manipulation of port dataset configurations without the need to manually create or manage individual port dataset indices.

        :type: PortDatasetIndices
        """

        self.macsec_txscs: MacSecTxScIndices = idx_mgr.IndexManager(
            conn,
            GenuineMacSecTxScIdx, # type: ignore
            module_id,
            port_id
        )
        """MACSec TX SC Index Manager automatically creates and manages MACSec TX SC indices for the port.
        This allows for easy access and manipulation of MACSec TX SC configurations without the need to manually create or manage individual MACSec TX SC indices.
        This is only available on ports that support MACSec.

        :type: MacSecTxScIndices
        """

        self.macsec_rxscs: MacSecRxScIndices = idx_mgr.IndexManager(
            conn,
            GenuineMacSecRxScIdx, # type: ignore
            module_id,
            port_id
        )
        """MACSec RX SC Index Manager automatically creates and manages MACSec RX SC indices for the port.
        This allows for easy access and manipulation of MACSec RX SC configurations without the need to manually create or manage individual MACSec RX SC indices.
        This is only available on ports that support MACSec.

        :type: MacSecRxScIndices
        """

        self.capabilities = P_CAPABILITIES(conn, module_id, port_id)
        """Port capabilities. This attribute provides information about the capabilities of the port, including supported speeds, protocols, and features. It allows the user to understand what features the port can do and how some features can be configured.

        :type: P_CAPABILITIES
        """

        self.capabilities_ext = P_CAPABILITIES_EXT(conn, module_id, port_id)
        """Extended capabilities. Provides the same information as the ``capabilities`` attribute, but in JSON string format.

        :type: P_CAPABILITIES_EXT
        """

        self.loopback = P_LOOPBACK(conn, module_id, port_id)
        """The loopback mode for a port. Ports can be configured to perform two different kinds of loopback: 
        
        1. Off: Traffic flows naturally out of the port 
        2. External RX-to-TX loopback, where the received packets are re-transmitted immediately. The packets are still processed by the receive logic, and can be captured and analyzed.
        
          * L1 RX-to-TX: Any received packet is bounced back through TX
          * L2 RX-to-TX: Same as L1 RX-to-TX yet it also swaps SRC MAC address with DST MAC address
          * L3 RX-to-TX: Same as L1 RX-to-TX yet it also swaps SRC IP address with DST IP address
        
        3. Internal TX-to-RX loopback, where the transmitted packets are received directly by the port itself. This is mainly useful for testing the generated traffic patterns before actual use.
        
          * TX(on)-to-RX: Packet goes out of TX but also internally direct to RX
          * TX(off)-to-TX: Packet goes directly to RX (No link sync needed)

        4. Port-to-port: Any received packet goes out through the neighbor port.

        :type: P_LOOPBACK
        """

        self.ifg = P_INTERFRAMEGAP(conn, module_id, port_id)
        """Interframe gap configuration. The minimum gap between packets in the traffic generated for a port. The gap includes the Ethernet preamble.

        :type: P_INTERFRAMEGAP
        """

        self.payload = Payload(conn, module_id, port_id)
        """Payload configuration.
        
        :type: Payload
        """

        self.tpld = TPLD(conn, module_id, port_id)
        """Test payload config.

        :type: TPLD
        """

        self.gap_monitor = P_GAPMONITOR(conn, module_id, port_id)
        """Gap monitor. The gap-start and gap-stop criteria for the port's gap monitor. The gap monitor
        expects a steady stream of incoming packets, and detects larger-than-allowed
        gaps between them. Once a gap event is encountered it requires a certain number
        of consecutive packets below the threshold to end the event.

        :type: P_GAPMONITOR
        """

        self.arp_rx_table = P_ARPRXTABLE(conn, module_id, port_id)
        """Port ARP reply table. It is used by the port to reply the ARP requests for the streams on the port. The port will reply to ARP requests with the MAC address of the entry that matches the request. If no matching entry is found, the port will not respond to the ARP request.

        :type: P_ARPRXTABLE
        """

        self.ndp_rx_table = P_NDPRXTABLE(conn, module_id, port_id)
        """Port NDP reply table. It is used by the port to reply the NDP requests for the streams on the port. The port will reply to NDP requests with the MAC address of the entry that matches the request. If no matching entry is found, the port will not respond to the NDP request.

        :type: P_NDPRXTABLE
        """

        self.capturer = PortCapture(conn, module_id, port_id)
        """Capturer configuration.

        :type: PortCapture
        """

        self.speed = Speed(conn, module_id, port_id)
        """Speed configuration.

        :type: Speed
        """

        self.traffic = Traffic(conn, module_id, port_id)
        """Traffic control.

        :type: Traffic
        """

        self.imix = IMix(conn, module_id, port_id)
        """IMIX configuration.

        :type: Mix
        """

        self.latency = LatencyConfiguration(conn, module_id, port_id)
        """Latency measurement mode and configuration.

        :type: LatencyConfiguration
        """

        self.rate = TrafficRate(conn, module_id, port_id)
        """Traffic rate configuration.

        :type: Rate
        """

        self.tx_control = TxControl(conn, module_id, port_id)
        """TX control.

        :type: TxControl
        """

        self.multicast = Multicast(conn, module_id, port_id)
        """Multicast configuration.

        :type: Multicast
        """

        self.mac = MacControl(conn, module_id, port_id)
        """MAC configuration.
        
        :type: MacControl
        """

        self.ipv4 = IPv4(conn, module_id, port_id)
        """IPv4 address configuration.

        :type: IPv4
        """

        self.ipv6 = IPv6(conn, module_id, port_id)
        """IPv6 address configuration.

        :type: IPv6
        """

        self.local_states = ports_state.PortL23LocalState()
        """Local states. This is the cached information and state of the port that is stored locally.

        :type: PortL23LocalState
        """

        self.flash = P_FLASH(conn, module_id, port_id)
        """Make the test port LED for a particular port flash on and off with a 1-second interval. This is helpful when you need to identify a specific port within a chassis.

        :type: P_FLASH
        """

        self.power_rx = P_STATUS(conn, module_id, port_id)
        """Get the received signal level for optical ports.

        :type: P_STATUS
        """

        self.speed = Speed(conn, module_id, port_id)
        """Speed configuration.

        :type: GenuineSpeed
        """

        self.uat = UnavailableTime(conn, module_id, port_id)
        """UnAvailable Time configuration.

        :type: UnAvailableTime
        """

        self.statistics = Statistics(conn, module_id, port_id)
        """Statistics. This attribute provides access to the port's RX and TX statistics, including total traffic, errors, and other relevant metrics.

        :type: PortStatistics
        """

        self.macsec_rx = P_MACSEC_RX_ENABLE(conn, module_id, port_id)
        """MACSec RX enable. This will enable/disable the MACSec functionality on the RX side. With it ON, the RX port will try to decode the received packets. If it is OFF, the port will not try to decode any received packets.

        :type: P_MACSEC_RX_ENABLE        
        """

        self.mdix_mode = P_MDIXMODE(conn, module_id, port_id)
        """MDI/MDIX mode. Selects the MDI/MDIX behavior of copper interfaces
        
        :type: P_MDIXMODE
        """

        self.autoneg_selection = P_AUTONEGSELECTION(conn, module_id, port_id)
        """Whether the port responds to incoming auto-negotiation requests. Only applicable to electrical ports (RJ45).
        
        :type: P_AUTONEGSELECTION
        """

        self.eee = EnergyEfficientEthernet(conn, module_id, port_id)
        """Low Power mode settings.
        
        :type: LowPowerMode
        """

        self.runt = Runt(conn, module_id, port_id)
        """Runt frame settings.
        
        :type: Runt
        """

        self.preamble = Preamble(conn, module_id, port_id)
        """Preamble settings.
        
        :type: Preamble
        """
        
        self.brr = BRR(conn, module_id, port_id)
        """BroadR-Reach configuration.

        :type: BRR
        """
        
    @property
    def info(self) -> ports_state.PortL23LocalState:
        return self._local_states

    async def _setup(self):
        await self._local_states.initiate(self)
        self._local_states.register_subscriptions(self)
        self.l1 = PortLayer1(self._conn, self)
        return self

    on_speed_change = functools.partialmethod(utils.on_event, P_SPEED)
    """Register a callback to the event that the speed changes."""

    on_traffic_change = functools.partialmethod(utils.on_event, P_TRAFFIC)
    """Register a callback to the event that the traffic status changes."""

    on_speed_selection_change = functools.partialmethod(utils.on_event, P_SPEEDSELECTION)
    """Register a callback to the event that the speed mode changes."""

    on_macsec_rx_enable_change = functools.partialmethod(utils.on_event, P_MACSEC_RX_ENABLE)
    """Register a callback to the event that the port MACsec RX enable status changes."""

    on_dynamic_change = functools.partialmethod(utils.on_event, P_DYNAMIC)
    """Register a callback to the event that the dynamic traffic setting changes."""
